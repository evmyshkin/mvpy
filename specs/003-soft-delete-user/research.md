# Research: Деактивация пользователя через API

**Фича**: 003-soft-delete-user
**Дата**: 2026-02-06
**Цель**: Разрешить все технические вопросы из Phase 0 плана имплементации

---

## 1. Паттерн деактивации в SQLAlchemy

### Исследовательский вопрос
Какие лучшие практики для реализации деактивации с полем `is_active` в SQLAlchemy 2.0+?

### Решение
**Использовать булево поле `is_active` с default=True**

**Обоснование**:
- `is_active: Mapped[bool]` - булев флаг для управления активностью пользователя
- Default значение `True` для новых пользователей
- При деактивации устанавливается в `False`
- Простой и явный подход, соответствующий YAGNI принципу (нет временных меток)

**Реализация в модели**:
```python
from sqlalchemy import Boolean

is_active: Mapped[bool] = mapped_column(
    Boolean,
    nullable=False,
    default=True,
    server_default='true',
)
```

**Альтернативы рассмотрены**:
1. Использование `deleted_at` (timestamp) - **отклонено** because: избыточно для текущих требований, нет необходимости знать время деактивации
2. Использование двух полей (`is_active` + `deactivated_at`) - **отклонено** according to: YAGNI, пользователь указал что временная метка не нужна
3. Использование SQLAlchemy ORM events для автоматической фильтрации - **отклонено** because: скрытое поведение нарушает принцип явности (конституция VI)

---

## 2. HTTP статусы для DELETE-операций

### Исследовательский вопрос
Какие правильные HTTP статусы для операции деактивации?

### Решение
**204 No Content для успешной деактивации, 404 Not Found если пользователь не существует**

**Обоснование**:
- **204 No Content** - стандартный HTTP статус для успешного DELETE-запроса (RFC 7231)
- Пустое тело ответа (Content-Length: 0) соответствует REST best practices
- **404 Not Found** - если пользователь не существует (включая уже деактивированных)
- **400 Bad Request** - если email в path имеет некорректный формат

**Сопоставление с требованиями из spec.md**:
- FR-003: "Система ДОЛЖНА отвечать HTTP статус-кодом 204 (No Content)" ✅
- FR-005: "Система ДОЛЖНА возвращать HTTP статус-кодом 404 (Not Found)" ✅

**Альтернативы рассмотрены**:
1. **200 OK** с телом ответа - **отклонено** because: violates REST principles (DELETE должен возвращать 204)
2. **202 Accepted** - **отклонено** because: подходит для асинхронных операций, а деактивация синхронная
3. **200 OK** с обновлённым объектом пользователя - **отклонено** because: избыточная нагрузка, клиент уже имеет данные

---

## 3. Обработка race conditions

### Исследовательский вопрос
Как обработать одновременные запросы на деактивацию одного пользователя?

### Решение
**Idempotent DELETE: повторный запрос на деактивацию уже деактивированного пользователя возвращает 404**

**Обоснование**:
- Мягкое удаление - это idempotent операция (второй вызов не меняет состояние)
- Однако для клиентов деактивированный пользователь "не существует"
- Поэтому повторный DELETE возвращает 404 как при попытке удалить несуществующего пользователя
- `find_by_email` с фильтрацией `is_active=True` автоматически не найдёт деактивированного пользователя

**Реализация в UserService**:
```python
async def deactivate_user(self, session: AsyncSession, email: str) -> None:
    """Деактивация пользователя по email.

    Raises:
        HTTPException(404): Если пользователь не найден или уже деактивирован
    """
    user = await self.crud.find_by_email(session, email)
    if user is None:
        # Пользователь не существует или уже деактивирован
        raise HTTPException(
            status_code=HTTP_404_NOT_FOUND,
            detail=ErrorMessages.USER_NOT_FOUND.value,
        )

    # Деактивация - устанавливаем is_active=False
    await self.crud.deactivate_by_email(session, email)
```

**Альтернативы рассмотрены**:
1. **Возвращать 204** при повторной деактивации - **отклонено** because: нарушает принцип "деактивированные пользователи невидимы" для API клиентов
2. **Использовать 409 Conflict** - **отклонено** because: подходит для конфликтов данных, а не для idempotent DELETE
3. **Блокировка на уровне БД** (SELECT FOR UPDATE) - **отклонено** because: избыточная сложность, `find_by_email` с фильтрацией `is_active=True` уже обеспечивает атомарность

---

## Итоговые решения

| Вопрос | Решение | Обоснование |
|--------|----------|-------------|
| Поля для деактивации | Только `is_active` (Boolean, default=True) | YAGNI, пользователь указал что временная метка не нужна |
| HTTP статусы | 204 (успех), 404 (не найден), 400 (некорректный email) | REST best practices + FR требования |
| Race conditions | Idempotent с 404 на повторный DELETE | "Деактивированные пользователи невидимы" для API |

---

## Следующие шаги

1. ✅ Все исследовательские задачи разрешены
2. ➡️ Перейти к Phase 1: Design & Contracts
   - Создать `data-model.md` с детальной моделью данных
   - Создать `contracts/openapi.yaml` со спецификацией API
   - Обновить agent context

---

**Статус**: ✅ Phase 0 завершён, все технические вопросы решены
