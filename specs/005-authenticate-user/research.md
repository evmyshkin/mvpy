# Исследование: Аутентификация и авторизация пользователей

**Дата**: 2025-02-06
**Фича**: 005-authenticate-user
**Статус**: Завершено

## Цель исследования

Разрешить все технические неизвестные для реализации системы аутентификации и авторизации на основе JWT токенов в соответствии с конституцией проекта и спецификацией функции.

## Исследуемые вопросы

### 1. Выбор библиотеки для JWT

**Вопрос**: Какую библиотеку использовать для работы с JWT в Python 3.13 с FastAPI?

**Рассмотренные варианты**:
1. **python-jose[cryptography]** - Рекомендуемая библиотека для FastAPI
2. **PyJWT** - Популярная альтернатива
3. **authlib** - Более комплексное решение

**Решение**: **python-jose[cryptography]**

**Обоснование**:
- Официально рекомендуется в документации FastAPI
- Имеет встроенную поддержку RSA и ECDSA алгоритмов
- Активно поддерживается и совместима с Python 3.13
- Простая интеграция с Pydantic
- Поддерживает все необходимые операции: encode, decode, verify

**Альтернативы отклонены потому что**:
- PyJWT требует дополнительной настройки для работы с FastAPI
- authlib избыточен для текущих требований (только JWT, без OAuth2 провайдеров)

### 2. Алгоритм подписи токена

**Вопрос**: Какой алгоритм подписи использовать для JWT токенов?

**Рассмотренные варианты**:
1. **HS256** (HMAC-SHA256) - Симметричный алгоритм
2. **RS256** (RSA-SHA256) - Асимметричный алгоритм
3. **ES256** (ECDSA-SHA256) - Асимметричный алгоритм

**Решение**: **HS256**

**Обоснование**:
- Симметричный алгоритм достаточен для текущих требований (один сервис)
- Проще в настройке и деплое (только один секретный ключ)
- Быстрее асимметричных алгоритмов
- Рекомендуется для stateless JWT когда нет микросервисов

**Альтернативы отклонены потому что**:
- RS256/ES256 избыточны для single-service архитектуры
- Требуют управления парами публичных/приватных ключей
- Больш overhead без дополнительных преимуществ безопасности в текущей архитектуре

**Примечание**: Если в будущем появится необходимость в микросервисах, можно мигрировать на RS256 без изменения формата токена.

### 3. Структура JWT payload (claims)

**Вопрос**: Какие поля включить в JWT токен?

**Рассмотренные варианты**:
1. **Minimal**: только user_id
2. **Standard**: user_id, exp, iat, sub
3. **Extended**: user_id, exp, iat, sub, is_active, email

**Решение**: **Standard с is_active**: user_id, exp, iat, sub, is_active

**Обоснование**:
- `user_id` (sub): Идентификация пользователя (стандартный claim)
- `exp` (expiration): Время истечения токена (безопасность)
- `iat` (issued at): Время выдачи (для аудита)
- `is_active`: Статус на момент выдачи (требование FR-016)
- `email` НЕ включён для минимизации размера токена (privacy)

**Альтернативы отклонены потому что**:
- Без `is_active`: невозможно проверить активный статус без запроса к БД
- С `email`: увеличивает размер токена без необходимости для авторизации
- Без `exp`: невозможно отозвать токен по времени истечения

**Пример payload**:
```json
{
  "sub": "123",
  "user_id": 123,
  "is_active": true,
  "iat": 1736123456,
  "exp": 1736209856
}
```

### 4. Механизм отзыва токенов (logout)

**Вопрос**: Как реализовать отзыв токенов при выходе из системы?

**Рассмотренные варианты**:
1. **Blacklist в БД** - Хранить отозванные токены
2. **Whitelist в БД** - Хранить активные токены
3. **Redis кэш** - Хранить отозванные токены в Redis
4. **Short-lived токены без отзыва** - Только expire

**Решение**: **Blacklist в БД (BlacklistedToken модель)**

**Обоснование**:
- Простота интеграции с существующей архитектурой (PostgreSQL уже используется)
- Постоянство данных (выживает при рестарте сервиса)
- Соответствует требованиям FR-007 (аннулировать токен при logout)
- Минимальный overhead: запись только при logout, проверка только при авторизации

**Альтернативы отклонены потому что**:
- Redis: дополнительная зависимость, сложность деплоя (противоречит принципу scoped-разработки)
- Whitelist: overhead записи при КАЖДОЙ аутентификации
- Short-lived без отзыва: не соответствует требованиям FR-006, FR-007

**Примечание**: Blacklist проверяется только для защищённых эндпоинтов (FR-010), не для auth endpoints.

### 5. Хранение JWT_SECRET_KEY

**Вопрос**: Где хранить секретный ключ для подписи JWT?

**Рассмотренные варианты**:
1. Переменная окружения `JWT__SECRET_KEY`
2. Файл конфигурации
3. Hash из секретного ключа приложения
4. Vault/секрет-менеджер

**Решение**: **Переменная окружения `JWT__SECRET_KEY`**

**Обоснование**:
- Следует принципу конституции (Pydantic Settings с `__` разделителем)
- Изоляция между окружениями (LOCAL, DEV, STAGE, PROD)
- Простота деплоя и ротации ключей
- Совместимость с существующей системой конфигурации

**Альтернативы отклонены потому что**:
- Файл конфигурации: риск попадания в git (безопасность)
- Hash: предсказуемость, слабая защита
- Vault: овер-скоп для текущих требований

**Требования к ключу**:
- Минимум 32 символа (256 бит для HS256)
- Рандомно сгенерированный
- Уникальный для каждого окружения

### 6. Параметризация длины сессии

**Вопрос**: Как реализовать параметризуемую длину сессии?

**Рассмотренные варианты**:
1. `JWT__ACCESS_TOKEN_EXPIRE_MINUTES` в конфиге
2. Константа в коде
3. Параметр в БД
4. Переменная окружения без `__` разделителя

**Решение**: `JWT__ACCESS_TOKEN_EXPIRE_MINUTES` в конфиге (Pydantic Settings)

**Обоснование**:
- Следует принципу конституции (разделитель `__` для вложенных переменных)
- Тестируемость: разные значения для тестов (PYTEST окружение)
- Гибкость настройки без пересборки
- Совместимость с FastAPI/Pydantic экосистемой

**Значения по умолчанию**:
- LOCAL/DEV: 60 минут (для удобства разработки)
- PYTEST: 999 минут (для стабильности тестов)
- PROD: 15 минут (для безопасности)

**Альтернативы отклонены потому что**:
- Константа: требует пересборки для изменения
- В БД: overhead запроса, избыточность
- Без `__` разделителя: противоречит конституции

### 7. Проверка is_active при авторизации

**Вопрос**: Как проверять активный статус пользователя при каждом запросе?

**Рассмотренные варианты**:
1. **Только из токена** (на момент выдачи)
2. **Только из БД** (актуальное состояние)
3. **Гибрид**: токен + БД при каждом запросе

**Решение**: **Гибридный подход**

**Обоснование**:
- Сначала проверяется `is_active` из токена (быстрая проверка, FR-016)
- Если `is_active=False` в токене → сразу отказ (без запроса к БД)
- Если `is_active=True` в токене → проверяется токен в blacklist (для logout)
- Дополнительно: пользователь МОЖЕТ быть деактивирован после выдачи токена (граничный случай)

**Реализация**:
```python
# Порядок проверок в middleware/dependency:
1. Токен валиден? (JWT decode)
2. Токен не истёк? (exp > now)
3. Токен не в blacklist? (запрос к БД)
4. is_active=True в токене? (из payload)
```

**Альтернативы отклонены потому что**:
- Только из токена: не обрабатывает деактивацию во время сессии (граничный случай из спека)
- Только из БД: overhead запроса при каждом авторизованном запросе

**Компромисс**: Для MVP проверяем только токен, но добавляем комментарий в код, что при необходимости можно добавить проверку из БД.

### 8. Middleware vs Dependency Injection

**Вопрос**: Как проверять авторизацию для защищённых эндпоинтов?

**Рассмотренные варианты**:
1. **Middleware** - Глобальная проверка для всех запросов
2. **Dependency Injection** - Проверка через Depends()
3. **Декоратор** - @require_auth на функциях

**Решение**: **Dependency Injection (Depends)**

**Обоснование**:
- Рекомендуется в документации FastAPI
- Гибкость: можно пропустить для публичных эндпоинтов (auth, register)
- Тестируемость: легко подменить зависимости в тестах
- Следует принципу конституции (Dependency Injection - принцип II)
- Автоматическая интеграция с OpenAPI

**Альтернативы отклонены потому что**:
- Middleware: сложнее исключить публичные эндпоинты, требует whitelist
- Декоратор: не интегрируется с FastAPI Depends, хуже тестируемость

**Реализация**:
```python
# app/api/v1/controllers/auth.py
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """Dependency для получения текущего пользователя из токена."""
    ...

# В защищённых эндпоинтах:
@router.get("/users/{user_id}")
async def get_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(connector.get_session),
):
    ...
```

### 9. Локализация сообщений об ошибках

**Вопрос**: Как локализовать сообщения об ошибках аутентификации на русский?

**Рассмотренные варианты**:
1. **Enum с сообщениями** (следует конституции XVII)
2. Словарь сообщений
3. f-строки в коде
4. Библиотека локализации (i18n)

**Решение**: **Enum с сообщениями**

**Обоснование**:
- Следует принципу конституции (XVII: хранить тексты в Enum)
- Централизованное управление сообщениями
- Поддержка типизации (MyPy проверит наличие сообщения)
- Простота рефакторинга

**Реализация**:
```python
# app/api/utils/enums/auth.py
class AuthErrorMessage(str, Enum):
    INVALID_CREDENTIALS = 'Неверный email или пароль'
    INACTIVE_USER = 'Учётная запись неактивна'
    INVALID_TOKEN = 'Невалидный токен авторизации'
    TOKEN_EXPIRED = 'Срок действия токена истёк'
```

**Альтернативы отклонены потому что**:
- Словарь: нетипизированный, риск опечаток
- f-строки: дублирование кода, трудно рефакторить
- i18n: овер-скоп для MVP (только русский язык)

### 10. Тестирование JWT токенов

**Вопрос**: Как тестировать эндпоинты с JWT авторизацией?

**Рассмотренные варианты**:
1. **Mock dependency** - Подменять get_current_user в тестах
2. **Real tokens** - Генерировать реальные JWT в фикстурах
3. **Skip auth** - Отключать авторизацию в тестах

**Решение**: **Real tokens в фикстурах**

**Обоснование**:
- Проверяет полную интеграцию (не mock)
- Стабильность: тесты падают только при реальных багах
- Совместимость с существующей архитектурой (conftest.py)
- Следует принципу конституции (VIII: использовать Pydantic модели)

**Реализация**:
```python
# tests/conftest.py
@pytest.fixture
def auth_headers_for_user(valid_user_request: UserCreateRequest) -> dict:
    """Генерирует валидные JWT заголовки для пользователя."""
    # 1. Создаём пользователя в БД
    # 2. Генерируем JWT токен
    # 3. Возвращаем {"Authorization": f"Bearer {token}"}

@pytest.fixture
def expired_auth_headers() -> dict:
    """Генерирует истёкший JWT токен."""
```

**Альтернативы отклонены потому что**:
- Mock: не тестирует реальную логику JWT
- Skip auth: пропускает проверку цели (нет тестов безопасности)

## Резюме решений

| Решение | Выбор | Обоснование |
|---------|-------|-------------|
| **Библиотека JWT** | python-jose[cryptography] | Рекомендуется FastAPI, простая интеграция |
| **Алгоритм подписи** | HS256 | Достаточен для single-service, прост в настройке |
| **JWT payload** | user_id, exp, iat, sub, is_active | Баланс размера и функциональности |
| **Отзыв токенов** | Blacklist в БД | Простота, постоянство, соответствует требованиям |
| **Хранение ключа** | `JWT__SECRET_KEY` env var | Безопасность, следует конституции |
| **Длина сессии** | `JWT__ACCESS_TOKEN_EXPIRE_MINUTES` | Параметризуемость, тестируемость |
| **Проверка is_active** | Из токена + blacklist | Баланс скорости и актуальности |
| **Авторизация** | Dependency Injection | FastAPI best practice, тестируемость |
| **Локализация** | Enum с сообщениями | Следует конституции, типизация |
| **Тестирование** | Real tokens в fixtures | Полная интеграция, стабильность |

## Зависимости для установки

```bash
# Добавить в pyproject.toml:
dependencies = [
    # ... существующие ...
    "python-jose[cryptography]>=3.3.0",  # Для JWT операций
]

# Или через uv:
uv add "python-jose[cryptography]>=3.3.0"
```

## Следующие шаги (Phase 1)

1. Создать `data-model.md` с описанием BlacklistedToken модели
2. Создать `contracts/auth.http` с примерами HTTP запросов
3. Создать `quickstart.md` с инструкциями по локальному запуску
4. Обновить agent context для новой технологии (JWT)

**Статус**: ✅ Все NEEDS CLARIFICATION разрешены, можно переходить к Phase 1
