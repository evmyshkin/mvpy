# Директория для работы со `speckit`

Основные принципы описаны в корневом `README.md`

## Содержимое
### md-файлы
Будут появляться по мере работы `speckit`
### Папка `spec_input`
Содержит шаблоны текстовых файлов для удобного промтинга разных вызовов функций `speckit`.

## Флоу

Инструкция, как по шагам с помощью `speckit` был запущен этот проект с помощью ИИ-агента с нуля. 
Часть контекста оставляю тут для переиспользования в других проектах как шпаргалку.

## Важные принципы
- Если в проекте уже есть `consitution.md`, для внедрения новых фич можно начать с команды `specify` по порядку дальше.
- С изменением архитетктуры проекта нужно не забывать обновлять `constituion`, `plan`, `tasks`. Без этого инференс будет по старым данным и его придется вручную исправлять.
- Полезная [статья](https://habr.com/ru/articles/964368/) для хороших практик команд `speckit`, которые я описал ниже.
- Для команд, требующих аргументов с деталями ТЗ, можно использовать ChatGPT.
- Рекомендую перечитывать все, что генерит нейронка. Не нужно раздувать ТЗ за скоуп, который требует заказчик.

## 1. `/speckit.constitution` – Принципы архитектуры
- Конституция — набор принципов, от которых AI не должен отступать. 
- Их можно указать после команды в аргумент. Например: tdd, чистый код, документация к публичным методам. 
- Все остальные команды зависят от неё. 
- На выходе соберет файл `.specify/memory/constitution.md`
- На вход можно передать шаблон `specs/spec_prompts/constitution_prompt.md`
- Шаблон содержит текущий стек, архитектуру, дерево проекта, и хорошие практикам контроля за работой ИИ. 
- При желании, можно оставить шаблон, как есть.
```bash
/speckit.specify @constitution_prompt.md
```
Либо описать конституцию текстом в CLI:
```bash
/speckit.constitution <core_principals>
```

## 2. `/speckit.specify` – Бизнес-требования
- Здесь нужно описать фичу. Не указывать техническую реализацию. Не засовывать все бизнес-фичи в одну команду, мыслить итерациями. 
- Сначала даем агенту последующими командами реализовать MVP, дальше усложняем повторными итерациями `specify`.
- Создаст файл `specs/001-feature-name/spec.md`
- На вход можно передать шаблон `specs/spec_prompts/specify_prompt.md`
- Предварительно, можно ознакомиться с примером user-story `specs/spec_prompts/specify_prompt_example.md`
```bash
/speckit.specify @specify_prompt.md
```
Либо описать фичу текстом в CLI:
```bash
/speckit.specify <business_feature>
```

## 3. `/speckit.clarify` – Уточнения
- Агент задаст вопросы, которые у него вызвал `specify`. 
- Поможет сформулировать более точные бизнес-требования, минимизировать серые зоны. 
- Создаст файл `specs/001-feature-name/clarify.md`
```bash
/speckit.clarify
```

## 4. checklist – Самопроверка пользователем
- Агент составит чеклист на указанную пользователем тему
- Создаст файл в `specs/001-feature-name/checklists`. На список нужно посмотреть самому и ответить для себя на вопросы, что я упускаю. Добавить изменения в повторный вызов команд выше по списку.
- Темы для самопроверки могут быть любые: `security`, `personal data`, `ux`, `performance`, `scalability` и тд.
```bash
/speckit.checklist <topic>
```

## 5. `/speckit.plan` – Архитектура и имплементация
- Это мост между «что нужно построить» и «какой код писать». 
- Здесь решаются технические вопросы: Какую архитектуру использовать? Какие библиотеки подключить? Как структурировать код? Как спроектировать базу данных?
- Создаст файлы `specs/001-feature-name/plan.md`, `specs/001-feature-name/research.md` и специфичные имплементации md-файлы.
- На вход можно передать шаблон `specs/spec_prompts/plan_prompt.md`
- При необходимости, можно явно детализировать модели БД, ручки API и другие, низкоуровневые вводные.
```bash
/speckit.specify @plan_prompt.md
```
Либо описать фичу текстом в CLI:

```bash
/speckit.plan <tech_stack>
```

## 6. `/speckit.tasks` – Разбивка на задачи
- Создает список задач с подзадачами из плана
- Сначала делаем X. Для этого сделаем a, b, c. 
- Затем делаем Y и тд. 
- Задачи учитывают конституцияю, бизнес-требования, уточнения и план, описанные ранее. 
- Рекомендуется задачи перечитать и убрать некритичные для наших целей. 
- В задачи могут попасть бантики. 
- Создаст `specs/001-feature-name/tasks.md`.
```bash
/speckit.tasks
```

## 7. `/speckit.analyze` – Поиск проблем
- Ищет конфликты в ранее сгенерированных md-артефактах. 
- Финальная самопроверка агента перед имплементацией. 
```bash
/speckit.analyze
```

## 8. `/speckit.implement` – Реализация
- Реализует фичу из `specs` по всем созданным спецификациям. 
- Рекомендуется следить за каждым шагом разработки, не давать нейронке делать весь проект в одно нажатие. 
- Лучше реализовывать явно по фазам из `tasks.md`.

### Воркфлоу
1. Новая сессия чата
2. /speckit.implement Phase 1
3. Ждём завершения
4. Тестируем результат
5. Коммитим
6. Закрываем сессию (/clear)
7. Новая сессия → `/speckit.implement` Phase 2

### Варианты команд
**Хорошая практика**: сделать конкретную фазу или конкретные номера задач.
- Можно делать задачу итеративно.
- Следить за прогрессом и вовремя останавливаться.
- Делать коммиты между фазами или задачами.
- Управлять разутым контекстом и вовремя рестартовать сессии.
```bash
/speckit.implement Phase 1 # Сделать задачи только из первой фазы фичи
```
```bash
/speckit.implement T001, T002 # Сделать только эти задачи из фазы
```

**Рисковая практика**: вызвать команду без аргументов. 
- Будет сложно следить, где агент остановился. 
- Сложнее управлять контекстом и менеджерить галлюцинации. 
- Сложнее управлять коммитами.
```bash
/speckit.implement # Отправить делать все
```
