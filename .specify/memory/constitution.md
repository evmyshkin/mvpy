<!--
Отчет о синхронизации
==================
Версия: 0.0.0 → 1.0.0
Обоснование: Первичная ратификация конституции с комплексными архитектурными принципами

Измененные принципы:
- Н/Д (первая версия)

Добавленные секции:
- Основные принципы (12 принципов)
- Архитектурные стандарты
- Рабочий процесс разработки
- Управление

Удаленные секции:
- Н/Д (первая версия)

Статус шаблонов:
- ✅ .specify/templates/plan-template.md - Проверено и согласовано
- ✅ .specify/templates/spec-template.md - Проверено и согласовано
- ✅ .specify/templates/tasks-template.md - Проверено и согласовано
- ✅ README.md - Проверено и согласовано
- ✅ CLAUDE.md - Проверено и согласовано

Следующие TODO:
- Отсутствуют

-->

# Конституция MVP-сервиса

## Основные принципы

### I. Технологический стек

- **API Framework**: Использовать FastAPI для проектирования всех API endpoints
- **Версия Python**: Использовать синтаксис Python 3.13 (обязательно)
- **Взаимодействие с БД**: Использовать SQLAlchemy 2.0+ с асинхронной поддержкой (драйвер AsyncPG)
- **Валидация**: Использовать Pydantic V2 с Annotated типизацией
- **Миграции БД**: Использовать Alembic для всех миграций базы данных
- **База данных**: PostgreSQL 17 как основная СУБД
- **Хеширование паролей**: Использовать bcrypt==4.0.1 через passlib (версия фиксирована для совместимости)
- **Менеджер пакетов**: Использовать UV как пакетный менеджер

**Обоснование**: Стандартизированный стек обеспечивает предсказуемость, упрощает онбординг и поддержку, а также гарантирует совместимость всех компонентов системы. Фиксированная версия bcrypt 4.0.1 предотвращает конфликты с passlib.

### II. Dependency Injection

- Использовать механизм Dependency Injection в FastAPI для улучшения тестируемости и гибкости приложения. 
- Все зависимости должны явно объявляться через FastAPI Depends.

**Обоснование**: DI обеспечивает легкое тестирование через мокирование зависимостей, четкое отображение связей между компонентами и упрощает рефакторинг.

### III. Type Annotations

- В коде использовать type annotations для всех функций, методов и переменных. 
- Строгая типизация обязательна.

**Обоснование**: Type annotations улучшают читаемость кода, позволяют статическим анализаторам (MyPy) находить ошибки до выполнения и служат документацией.

### IV. Управление конфигурацией

- Все настройки и конфигурации должны быть реализованы через Pydantic V2 Settings с использованием аннотированной типизации. 
- Вложенные переменные окружения используют разделитель `__` (например, `POSTGRES__HOST`).

**Обоснование**: Pydantic Settings обеспечивают строгую валидацию конфигурации при запуске, поддержку типов данных и раннее обнаружение ошибок конфигурации.

### V. Чистая архитектура

- Архитектура проекта должна четко следовать принципу разделения слоёв: Controller → Service → CRUD → DB
- Controllers (`app/api/v1/controllers/`): обработчики FastAPI маршрутов, dependency injection, вызов CRUD- или Service- методов.
- Services (`app/services/`): бизнес-логика, оркестрация CRUD операций
- CRUD (`app/db/crud/`): прямые операции с БД используя генерик `BaseCrud`
- Models (`app/db/models/`): определения таблиц SQLAlchemy, наследуются от `BaseDBModel`

**Обоснование**: Четкое разделение слоёв обеспечивает тестируемость каждого слоя независимо, упрощает понимание кода и позволяет изменять слои без влияния на другие.

### VI. Абстракция базовых классов

Использовать базовые классы для унификации операций:

- BaseDBModel: базовая SQLAlchemy модель с общими полями (id, created_at, updated_at)
- BaseCrud[ModelType]: генерик CRUD операций (add_one, find_one_or_none, find_all, update_one_or_none, delete_one)
- BaseService: базовый сервисный класс для бизнес-логики
- BaseSchema: общие Pydantic модели
- BaseClient: общий асинхронный клиент
- Не добавлять в Base-классы функциональность, специфичную для доменов. Например, в BaseCrud не добавлять методы для работы с конкретными полями или таблицами. Выносить в отдельный слой.

**Обоснование**: Базовые классы уменьшают дублирование кода, обеспечивают единый интерфейс для операций и упрощают добавление новой функциональности.

### VII. Управление сессиями БД

- Использовать dependency `connector.get_session()` для асинхронных сессий БД в контроллерах. 
- Коннектор автоматически выбирает правильный URI БД в зависимости от окружения (LOCAL, DEV, STAGE, PROD, PYTEST).

**Обоснование**: Централизованное управление сессиями обеспечивает корректную работу с разными окружениями, упрощает тестирование через подмену URI для PYTEST и предотвращает утечки соединений.

### VIII. Требования к тестированию

- Тестирование является обязательной частью разработки
- Использовать pytest-asyncio для асинхронных тестов
- Генерировать тестовые данные через Faker
- Использовать Pydantic модели для создания тестовых данных вместо ручного формирования dict
- Повторяющиеся фикстуры нужно выносить в отдельный каталог `fixtures`. 
- Если фикстура нужна для большинства тестов, добавлять ее в `conftest.py`.
- Группировать авто-тесты по бизнес-функциональности с помощью `pytest.mark` 
- Убеждаться, что тесты откатывают данные из БД после исполнения.
- Запускать тесты в отдельную, тестовую БД. Убедиться, что адреса основной и тестовой БД отличаются.
- Стремиться к максимальному покрытию ветвлений (--cov-branch)
- Структура тестов должна зеркалить структуру app/
- Запускать тесты после каждого изменения кода (make test)
- Ассерты в тестах должны проверять не только структуру ответа и статус код, но и соответствие значений.

**Обязательный рабочий процесс:**
1. Перед правкой кода: проверить наличие тестов на изменяемый функционал
2. Написание тестов: если тестов нет - написать их одновременно с кодом или сразу после
3. Запуск тестов: после изменения кода ОБЯЗАТЕЛЬНО запустить make test
4. Pre-commit hooks: после правок запустить проверки: pre-commit run --all-files

**Обоснование**: Тесты обеспечивают качество кода, предотвращают регрессии, служат живой документацией API и позволяют уверенно рефакторить код. Использование Pydantic моделей для тестовых данных обеспечивает валидацию на этапе создания тестовых данных и уменьшает дублирование. Фикстуры в conftest.py переиспользуются между разными типами тестов (API, service, CRUD).

### IX. Стандарты качества кода

- Линтер: Ruff с полным набором правил (E, W, I, N, F, UP, T20, SIM, B, ASYNC, G, D, RUF, ANN)
- Тайпинг: MyPy с плагином Pydantic для проверки типов
- Форматирование: одинарные кавычки, пробельные отступы, длина строки 100 символов
- Докстринги: Google-style на публичных классах и функциях, только на русском языке
- Pre-commit hooks: автоматические проверки качества кода перед коммитом

**Обоснование**: Единые стандарты кода обеспечивают читаемость, уменьшают количество ошибок, упрощают code review и позволяют команде работать согласованно.

### X. Дисциплина scoped-разработки

- Делать только то, что требуется в фичах. 
- Не добавлять лишнего функционала "на будущее". 
- Следовать YAGNI (You Aren't Gonna Need It) принципу.
- Не добавлять от себя требования по производительности, если их явно не запросили.

**Обоснование**: Избыточный функционал увеличивает сложность, время разработки и поддержку. Код должен быть минимально необходимым для решения текущей задачи.

### XI. Документация и локализация

- Все `.md` файлы со спецификацией должны быть на русском языке
- Документировать код только на русском языке
- Писать docstring для всех публичных функций и классов
- Валидационные ошибки должны быть локализованы на русский язык в схемах, которые возвращаются пользователю в API
- Структура docstring согласно Google Docstring
- Никогда не читать .env файлы (содержат секретные данные)
- Для понимания структуры конфигурации использовать только .env.example

**Обоснование**: Русскоязычная документация обеспечивает доступность для команды. Docstring-и служат встроенной документацией API. Запрет на чтение .env предотвращает случайную утечку секретов.

### XII. Принципы проектирования API

- Главный роутер: app/api/router.py - включает все версии API и дополнительные эндпоинты
- Версионирование: префикс /v1 для версии 1 API
- Модульные роутеры: каждая фича имеет свой роутер в app/api/v1/controllers/
- Healthcheck: доступен на корневом пути /
- Методы BaseCRUD автоматически raise HTTPException при ошибках БД
- В контроллерах использовать соответствующие HTTP статусы из starlette.status
- Не нагружать логику внутри контроллеров. Возможен либо вызов метода CRUD, либо вызов метода сервиса. 
- Другой логики внутри контроллеров не допускается. Она должна быть реализована внутри соответствующего слоя.

**Обоснование**: Версионирование API позволяет эволюционировать API без ломающих изменений для клиентов. Модульные роутеры обеспечивают масштабируемость. Тонкость слоя контроллеров позволяет четко разделять зоны ответственности.

### XIII. Git-ветвление

- Делать `specify`-фичу в отдельной ветке, продолжая нумерацию предыдущей `specs` директории.
- Использовать сквозную нумерацию фичей и их веток (001, 002, и тд.) вне зависимости о того, связаны ли фичи.

**Обоснование**: Стратегия ветвления обеспечивает параллельную разработку нескольких фич, изоляцию изменений и понятную историю коммитов.

### XIV. SQLAlchemy

- Используем наиболее производительные методы SQLAlchemy.
- `insert()` вместо `add()` для массовых вставок. 
- `select()` вместо `query()` для получения данных. 

**Обоснование**: Некоторые методы ORM работают медленнее при частом взаимодействии с БД. Рекомендуется использовать более производительные альтернативы.

### XV. Дополнительная документация `openapi` не нужна

- В задачах на реализацию не ставим себе целью описать `openapi` спецификации
- `FastAPI` из коробки и так генерирует ее
- Тестировать `openapi` спецификацию не нужно

**Обоснование**: Не нужны лишние затраты на то, что уже и так автоматизировано и обеспечено фреймворком FastAPI.

### XVI.Конфигурация окружений

- Окружения: LOCAL, DEV, STAGE, PROD, PYTEST
- Каждое окружение имеет свою конфигурацию БД через переменные окружения. 
- Коннектор в session.py автоматически выбирает правильный URI.

**Обоснование**: Разделение окружений обеспечивает изоляцию данных, безопасное тестирование и предсказуемое поведение в разных стадиях lifecycle.

### XVII.Код-стиль

- Использовать именованные аргументы вместо позиционных где это возможно и не противоречит хорошит практикам.
- Для текстов сообщений в методах не использовать сырые строки. Вместо этого, хранить тексты в Enum.
- Использовать импорты на уровне модуля. Не использовать локальные импорты в методы.

**Обоснование**: Улучшается читаемость кода.

### XVIII. Сервисный слой

- Сервисы должны использовать Pydantic-схемы в своих методах для получения аргументов определенного типа и вставки данных в БД.
- Сервисы должны передавать данные в data-слой с `помощью model_dumps()`.

**Обоснование**: Уменьшение дублирования кода. Строгая валидация данных на уровне сервиса. Улучшается читаемость кода


## Структура проекта

```
app/
├── api/                    # API слой (обработчики HTTP запросов)
│   ├── extra/              # Дополнительные эндпоинты
│   │   └── healthcheck.py
│   ├── router.py           # Главный API роутер
│   ├── utils/              # Утилиты для API
│   │   └── enums/
│   │       ├── base.py
│   │       └── env_enum.py
│   └── v1/                 # API v1
│       ├── controllers/    # FastAPI route обработчики
│       │   └── users.py
│       ├── router.py       # API v1 маршрутизация
│       └── schemas/        # Pydantic модели запросов/ответов
│           ├── base.py
│           └── users.py
├── clients/                # Клиенты внешних API
│   └── base.py
├── config.py               # Конфигурация через Pydantic Settings
├── db/                     # Слой работы с базой данных
│   ├── base.py             # Базовая SQLAlchemy модель (BaseDBModel)
│   ├── crud/               # CRUD операции над моделями БД
│   │   ├── base.py         # Базовый CRUD класс (BaseCrud)
│   │   └── users.py        # CRUD для User
│   ├── models/             # SQLAlchemy ORM модели
│   │   └── user.py
│   └── session.py          # Асинхронное подключение к БД (DBConnector)
├── main.py                 # Точка входа FastAPI приложения
├── schemas/                # Общие Pydantic схемы
│   └── base.py
└── services/               # Слой бизнес-логики
    ├── base.py             # Базовый сервисный класс (BaseService)
    └── user_service.py     # Бизнес-логика для User
```


**Версия**: 1.0.0 | **Ратифицирована**: 2026-02-05 | **Последнее изменение**: 2026-02-05