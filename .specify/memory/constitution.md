<!--
Отчет о синхронизации
==================
Версия: 0.0.0 → 1.0.0
Обоснование: Первичная ратификация конституции с комплексными архитектурными принципами

Измененные принципы:
- Н/Д (первая версия)

Добавленные секции:
- Основные принципы (12 принципов)
- Архитектурные стандарты
- Рабочий процесс разработки
- Управление

Удаленные секции:
- Н/Д (первая версия)

Статус шаблонов:
- ✅ .specify/templates/plan-template.md - Проверено и согласовано
- ✅ .specify/templates/spec-template.md - Проверено и согласовано
- ✅ .specify/templates/tasks-template.md - Проверено и согласовано
- ✅ README.md - Проверено и согласовано
- ✅ CLAUDE.md - Проверено и согласовано

Следующие TODO:
- Отсутствуют

-->

# Конституция MVP-сервиса

## Основные принципы

### I. Технологический стек

- **API Framework**: Использовать FastAPI для проектирования всех API endpoints
- **Версия Python**: Использовать синтаксис Python 3.13 (обязательно)
- **Взаимодействие с БД**: Использовать SQLAlchemy 2.0+ с асинхронной поддержкой (драйвер AsyncPG)
- **Валидация**: Использовать Pydantic V2 с Annotated типизацией
- **Миграции БД**: Использовать Alembic для всех миграций базы данных
- **База данных**: PostgreSQL 17 как основная СУБД
- **Менеджер пакетов**: Использовать UV как пакетный менеджер

**Обоснование**: Стандартизированный стек обеспечивает предсказуемость, упрощает онбординг и поддержку, а также гарантирует совместимость всех компонентов системы.

### II. Dependency Injection

Использовать механизм Dependency Injection в FastAPI для улучшения тестируемости и гибкости приложения. Все зависимости должны явно объявляться через FastAPI Depends.

**Обоснование**: DI обеспечивает легкое тестирование через мокирование зависимостей, четкое отображение связей между компонентами и упрощает рефакторинг.

### III. Type Annotations

В коде использовать type annotations для всех функций, методов и переменных. Строгая типизация обязательна.

**Обоснование**: Type annotations улучшают читаемость кода, позволяют статическим анализаторам (MyPy) находить ошибки до выполнения и служат документацией.

### IV. Управление конфигурацией

Все настройки и конфигурации должны быть реализованы через Pydantic V2 Settings с использованием аннотированной типизации. Вложенные переменные окружения используют разделитель `__` (например, `POSTGRES__HOST`).

**Обоснование**: Pydantic Settings обеспечивают строгую валидацию конфигурации при запуске, поддержку типов данных и раннее обнаружение ошибок конфигурации.

### V. Чистая архитектура

Архитектура проекта должна четко следовать принципу разделения слоёв: Controller → Service → CRUD → DB

1. **Controllers** (`app/api/v1/controllers/`): обработчики FastAPI маршрутов, dependency injection, обработка запросов/ответов
2. **Services** (`app/services/`): бизнес-логика, оркестрация CRUD операций
3. **CRUD** (`app/db/crud/`): прямые операции с БД используя генерик `BaseCrud`
4. **Models** (`app/db/models/`): определения таблиц SQLAlchemy, наследуются от `BaseDBModel`

**Обоснование**: Четкое разделение слоёв обеспечивает тестируемость каждого слоя независимо, упрощает понимание кода и позволяет изменять слои без влияния на другие.

### VI. Абстракция базовых классов

Использовать базовые классы для унификации операций:

- **BaseDBModel**: базовая SQLAlchemy модель с общими полями (id, created_at, updated_at)
- **BaseCrud[ModelType]**: генерик CRUD операций (add_one, find_one_or_none, find_all, update_one_or_none, delete_one)
- **BaseService**: базовый сервисный класс для бизнес-логики
- **BaseSchema**: общие Pydantic модели

**Обоснование**: Базовые классы уменьшают дублирование кода, обеспечивают единый интерфейс для операций и упрощают добавление новой функциональности.

### VII. Управление сессиями БД

Использовать dependency `connector.get_session()` для асинхронных сессий БД в контроллерах. Коннектор автоматически выбирает правильный URI БД в зависимости от окружения (LOCAL, DEV, STAGE, PROD, PYTEST).

**Обоснование**: Централизованное управление сессиями обеспечивает корректную работу с разными окружениями, упрощает тестирование через подмену URI для PYTEST и предотвращает утечки соединений.

### VIII. Требования к тестированию

Тестирование является обязательной частью разработки:

- Использовать pytest-asyncio для асинхронных тестов
- Генерировать тестовые данные через Faker
- Стремиться к максимальному покрытию ветвлений (--cov-branch)
- Структура тестов должна зеркалить структуру app/
- Запускать тесты после каждого изменения кода (make test)

**Обязательный рабочий процесс:**
1. Перед правкой кода: проверить наличие тестов на изменяемый функционал
2. Написание тестов: если тестов нет - написать их одновременно с кодом или сразу после
3. Запуск тестов: после изменения кода ОБЯЗАТЕЛЬНО запустить make test
4. Pre-commit hooks: после правок запустить проверки: pre-commit run --all-files

**Обоснование**: Тесты обеспечивают качество кода, предотвращают регрессии, служат живой документацией API и позволяют уверенно рефакторить код.

### IX. Стандарты качества кода

- **Линтер**: Ruff с полным набором правил (E, W, I, N, F, UP, T20, SIM, B, ASYNC, G, D, RUF, ANN)
- **Тайпинг**: MyPy с плагином Pydantic для проверки типов
- **Форматирование**: одинарные кавычки, пробельные отступы, длина строки 100 символов
- **Докстринги**: Google-style на публичных классах и функциях, только на русском языке
- **Pre-commit hooks**: автоматические проверки качества кода перед коммитом

**Обоснование**: Единые стандарты кода обеспечивают читаемость, уменьшают количество ошибок, упрощают code review и позволяют команде работать согласованно.

### X. Дисциплина scoped-разработки

Делать только то, что требуется в фичах. Не добавлять лишнего функционала "на будущее". Следовать YAGNI (You Aren't Gonna Need It) принципу.

**Обоснование**: Избыточный функционал увеличивает сложность, время разработки и поддержку. Код должен быть минимально необходимым для решения текущей задачи.

### XI. Документация и локализация

- Документировать код только на русском языке
- Писать docstring для всех публичных функций и классов
- Структура docstring согласно Google Docstring
- Никогда не читать .env файлы (содержат секретные данные)
- Для понимания структуры конфигурации использовать только .env.example

**Обоснование**: Русскоязычная документация обеспечивает доступность для команды. Docstring-и служат встроенной документацией API. Запрет на чтение .env предотвращает случайную утечку секретов.

### XII. Принципы проектирования API

- Главный роутер: app/api/router.py - включает все версии API и дополнительные эндпоинты
- Версионирование: префикс /v1 для версии 1 API
- Модульные роутеры: каждая фича имеет свой роутер в app/api/v1/controllers/
- Healthcheck: доступен на корневом пути /
- Методы BaseCRUD автоматически raise HTTPException при ошибках БД
- В контроллерах использовать соответствующие HTTP статусы из starlette.status

**Обоснование**: Версионирование API позволяет эволюционировать API без ломающих изменений для клиентов. Модульные роутеры обеспечивают масштабируемость.

### XIII. Git-ветвление

- Делать фичу в ветке от main
- Делать подзадачи в ветках от фича-ветки
- Затем мержить подзадачи в фичу, а фичу в main

**Обоснование**: Стратегия ветвления обеспечивает параллельную разработку нескольких фич, изоляцию изменений и понятную историю коммитов.

## Архитектурные стандарты

### Структура проекта

```
app/
├── api/                    # API слой (обработчики запросов)
│   ├── v1/
│   │   ├── controllers/    # FastAPI route обработчики
│   │   ├── schemas/        # Pydantic модели запросов/ответов
│   │   └── router.py       # API v1 маршрутизация
│   ├── extra/              # Дополнительные эндпоинты (healthcheck и т.д.)
│   └── router.py           # Главный API роутер
├── clients/                # Клиенты внешних API
├── config.py               # Конфигурация через Pydantic Settings
├── db/
│   ├── base.py             # Базовый SQLAlchemy модель
│   ├── crud/               # Слой доступа к данным (BaseCrud)
│   ├── models/             # Модели таблиц БД
│   └── session.py          # Асинхронное подключение к БД
├── schemas/                # Общие Pydantic схемы
└── services/               # Слой бизнес-логики (BaseService)
```

### Ответственности базовых классов

- **BaseDBModel**: Базовая SQLAlchemy модель с общими полями (id, created_at, updated_at)
- **BaseCrud[ModelType]**: Дженерик CRUD операций для упрощения работы с базой данных и унификации операций (add_one, find_one_or_none, find_all, update_one_or_none, delete_one)
- **BaseService**: Базовый класс для всех сервисов бизнес-логики, с возможностью расширения в зависимости от специфики фич
- **BaseSchema**: Общие Pydantic модели для переиспользования

### Стандарты миграций

При создании новых моделей убедиться, что они импортированы в app/db/models/__init__.py, чтобы Alembic мог обнаружить их для автогенерации.

Миграции бывают двух типов:
1. **Схематические**: автогенерация из моделей (alembic revision --autogenerate)
2. **Миграции данных**: ручное написание SQL для изменения данных (alembic revision)

**Обоснование**: Автогенерация ускоряет разработку схематических изменений. Ручное написание необходимо для миграций данных, которые не могут быть автогенерированы.

## Рабочий процесс разработки

### Конфигурация окружений

Окружения: LOCAL, DEV, STAGE, PROD, PYTEST

Каждое окружение имеет свою конфигурацию БД через переменные окружения. Коннектор в session.py автоматически выбирает правильный URI.

**Обоснование**: Разделение окружений обеспечивает изоляцию данных, безопасное тестирование и предсказуемое поведение в разных стадиях lifecycle.

### Стандарты обработки ошибок

- Методы BaseCRUD автоматически raise HTTPException при ошибках БД
- В контроллерах использовать соответствующие HTTP статусы из starlette.status
- Ошибки БД перехватываются и конвертируются в HTTP 500 ошибки

**Обоснование**: Единая обработка ошибок упрощает отладку, обеспечивает предсказуемые ответы API и улучшает пользовательский опыт.

## Управление

### Процедура внесения изменений

Изменения в конституцию требуют:
1. Обоснования необходимости изменений
2. Commit с описанием влияния изменений

### Проверка соответствия

Все PRs и code review должны проверять соответствие конституции:
- Архитектурные слои (Controller → Service → CRUD → DB)
- Использование базовых классов
- Наличие тестов и покрытие
- Качество кода (ruff, mypy, pre-commit)
- Документация (docstrings на русском)
- Соблюдение workflow speckit

Сложность должна быть обоснована. Использовать CLAUDE.md для runtime руководства по разработке.

**Версия**: 1.0.0 | **Ратифицирована**: 2026-02-05 | **Последнее изменение**: 2026-02-05